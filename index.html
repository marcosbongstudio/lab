<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bong Studio - Personajes 3D</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            width: 100vw;
            height: 100vh;
            overflow: hidden;
            background: transparent;
        }
        
        #container {
            width: 100%;
            height: 100%;
        }
        
        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const container = document.getElementById('container');
        
        let scene, camera, renderer;
        let marcosModel, maruModel;
        let modelsLoaded = 0;
        
        // SOLO estas variables para scroll pause
        let isScrolling = false;
        let scrollTimeout;

        const CONFIG = {
            marcosURL: 'https://raw.githubusercontent.com/marcosbongstudio/lab/refs/heads/main/marcos.glb',
            maruURL: 'https://raw.githubusercontent.com/marcosbongstudio/lab/refs/heads/main/maria.glb',
            spacing: 3.5,
            headSensitivity: 1.0,
            headSensitivityY: 0.67,
            smoothness: 0.05,
            modelScale: 3,
            idleEnabled: true,
            idleSpeed: 0.3,
            maruDelay: 0.5,
        };

        // Mouse tracking
        const mouse = { x: 0, y: 0 };
        const targetRotation = { x: 0, y: 0 };
        const currentRotation = { x: 0, y: 0 };
        const currentRotationMaru = { x: 0, y: 0 };
        
        // Idle animation
        let isIdle = false;
        let lastMouseMoveTime = Date.now();
        let idleState = 'rotate';
        let idleStateTime = Date.now();
        let isTransitioning = false;
        let transitionProgress = 0;
        
        const IDLE_TIMEOUT = 2000;
        const IDLE_STATE_DURATION = 5000;
        const TRANSITION_SPEED = 0.02;

        function organicNoise(time, seed = 0) {
            const t = time + seed;
            return (
                Math.sin(t * 0.7) * 0.5 +
                Math.sin(t * 1.3) * 0.3 +
                Math.sin(t * 2.1) * 0.15 +
                Math.sin(t * 0.4) * 0.05
            );
        }

        function easeInOutCubic(t) {
            return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
        }

        function init() {
            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 8;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.0;
            renderer.setClearColor(0x000000, 0);
            
            container.appendChild(renderer.domElement);

            // Luces
            const ambientLight = new THREE.AmbientLight(0xffffff, 1.2);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 0.8);
            mainLight.position.set(5, 5, 5);
            scene.add(mainLight);

            // Mouse tracking
            const updateMousePosition = (x, y) => {
                mouse.x = x;
                mouse.y = y;
                targetRotation.y = mouse.x * CONFIG.headSensitivity;
                targetRotation.x = -mouse.y * CONFIG.headSensitivityY;
                
                lastMouseMoveTime = Date.now();
                if (isIdle) {
                    isIdle = false;
                    isTransitioning = true;
                    transitionProgress = 0;
                }
            };

            window.addEventListener('mousemove', (event) => {
                const x = (event.clientX / window.innerWidth) * 2 - 1;
                const y = (event.clientY / window.innerHeight) * 2 - 1;
                updateMousePosition(x, y);
            });

            window.addEventListener('message', (event) => {
                if (event.data && event.data.type === 'mousemove') {
                    updateMousePosition(event.data.x, event.data.y);
                }
            });

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // SOLO ESTA OPTIMIZACIÓN: Pausar durante scroll
            window.addEventListener('scroll', () => {
                isScrolling = true;
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    isScrolling = false;
                }, 200);
            }, { passive: true });

            loadModel(CONFIG.marcosURL, -CONFIG.spacing / 2, (model) => {
                marcosModel = model;
                checkModelsLoaded();
            });

            loadModel(CONFIG.maruURL, CONFIG.spacing / 2, (model) => {
                maruModel = model;
                checkModelsLoaded();
            });

            animate();
        }

        function loadModel(url, xPosition, callback) {
            const loader = new THREE.GLTFLoader();
            
            loader.load(
                url,
                (gltf) => {
                    const model = gltf.scene;
                    model.position.set(xPosition, 0, 0);
                    model.scale.set(CONFIG.modelScale, CONFIG.modelScale, CONFIG.modelScale);
                    
                    model.traverse((child) => {
                        if (child.isMesh && child.material) {
                            child.material.emissive = new THREE.Color(0x111111);
                            child.material.emissiveIntensity = 0.15;
                        }
                    });

                    scene.add(model);
                    callback(model);
                },
                undefined,
                (error) => {
                    console.error('Error cargando modelo:', error);
                }
            );
        }

        function checkModelsLoaded() {
            modelsLoaded++;
            if (modelsLoaded === 2) {
                console.log('✅ Modelos cargados');
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // SKIP si está scrolleando
            if (isScrolling) {
                return;
            }

            const now = Date.now();
            const timeSinceMouseMove = now - lastMouseMoveTime;
            
            // Idle logic
            if (CONFIG.idleEnabled && timeSinceMouseMove > IDLE_TIMEOUT && !isIdle && !isTransitioning) {
                isIdle = true;
                isTransitioning = true;
                transitionProgress = 0;
                idleStateTime = now;
            }

            if (isTransitioning) {
                transitionProgress += TRANSITION_SPEED;
                if (transitionProgress >= 1) {
                    transitionProgress = 1;
                    isTransitioning = false;
                }
            }

            if (isIdle) {
                if (now - idleStateTime > IDLE_STATE_DURATION) {
                    const states = ['rotate', 'look_sides', 'look_at_each_other'];
                    const currentIndex = states.indexOf(idleState);
                    idleState = states[(currentIndex + 1) % states.length];
                    idleStateTime = now;
                }

                const time = now * 0.001 * CONFIG.idleSpeed;
                let idleRotX = 0, idleRotY = 0;

                if (idleState === 'rotate') {
                    idleRotX = organicNoise(time, 0) * 0.3;
                    idleRotY = organicNoise(time, 100) * 0.5;
                } else if (idleState === 'look_sides') {
                    idleRotY = Math.sin(time * (0.5 + Math.sin(time * 0.3) * 0.3)) * 0.6;
                    idleRotX = Math.sin(time * 0.7) * 0.15;
                } else if (idleState === 'look_at_each_other') {
                    idleRotY = Math.sin(time * 0.4) * 0.15;
                    idleRotX = Math.sin(time * 0.6) * 0.1;
                }

                const factor = easeInOutCubic(transitionProgress);
                targetRotation.x = targetRotation.x * (1 - factor) + idleRotX * factor;
                targetRotation.y = targetRotation.y * (1 - factor) + idleRotY * factor;
            }

            // Interpolación suave
            currentRotation.x += (targetRotation.x - currentRotation.x) * CONFIG.smoothness;
            currentRotation.y += (targetRotation.y - currentRotation.y) * CONFIG.smoothness;

            currentRotationMaru.x += (targetRotation.x - currentRotationMaru.x) * (CONFIG.smoothness * CONFIG.maruDelay);
            currentRotationMaru.y += (targetRotation.y - currentRotationMaru.y) * (CONFIG.smoothness * CONFIG.maruDelay);

            // Aplicar rotaciones
            if (marcosModel) {
                marcosModel.rotation.x = currentRotation.x;
                marcosModel.rotation.y = currentRotation.y;
            }

            if (maruModel) {
                maruModel.rotation.x = currentRotationMaru.x;
                maruModel.rotation.y = currentRotationMaru.y;
            }

            renderer.render(scene, camera);
        }

        // GLTFLoader
        THREE.GLTFLoader = (function() {
            function GLTFLoader(manager) {
                this.manager = manager || THREE.DefaultLoadingManager;
            }
            GLTFLoader.prototype.load = function(url, onLoad, onProgress, onError) {
                const loader = new THREE.FileLoader(this.manager);
                loader.setResponseType('arraybuffer');
                loader.load(url, (data) => {
                    try {
                        this.parse(data, '', onLoad, onError);
                    } catch (e) {
                        if (onError) onError(e);
                    }
                }, onProgress, onError);
            };
            GLTFLoader.prototype.parse = function(data, path, onLoad, onError) {
                const magic = new Uint8Array(data, 0, 4);
                const isGLB = magic[0] === 0x67 && magic[1] === 0x6C && magic[2] === 0x54 && magic[3] === 0x46;
                
                if (!isGLB) {
                    if (onError) onError(new Error('Not a valid GLB file'));
                    return;
                }

                const view = new DataView(data);
                const jsonChunkLength = view.getUint32(12, true);
                const jsonChunkData = new Uint8Array(data, 20, jsonChunkLength);
                const jsonText = new TextDecoder().decode(jsonChunkData);
                const json = JSON.parse(jsonText);

                const scene = new THREE.Group();
                if (json.scenes && json.scenes.length > 0) {
                    const sceneIndex = json.scene !== undefined ? json.scene : 0;
                    const sceneData = json.scenes[sceneIndex];
                    
                    if (sceneData.nodes) {
                        sceneData.nodes.forEach(nodeIndex => {
                            this.parseNode(json, nodeIndex, scene, data);
                        });
                    }
                }

                onLoad({ scene: scene });
            };
            GLTFLoader.prototype.parseNode = function(json, nodeIndex, parent, glbData) {
                const nodeData = json.nodes[nodeIndex];
                const node = new THREE.Group();

                if (nodeData.mesh !== undefined) {
                    const mesh = this.parseMesh(json, nodeData.mesh, glbData);
                    if (mesh) node.add(mesh);
                }

                if (nodeData.children) {
                    nodeData.children.forEach(childIndex => {
                        this.parseNode(json, childIndex, node, glbData);
                    });
                }

                parent.add(node);
            };
            GLTFLoader.prototype.parseMesh = function(json, meshIndex, glbData) {
                const meshData = json.meshes[meshIndex];
                const group = new THREE.Group();

                meshData.primitives.forEach(primitive => {
                    const geometry = new THREE.BufferGeometry();
                    const attributes = primitive.attributes;

                    Object.keys(attributes).forEach(attributeName => {
                        const accessorIndex = attributes[attributeName];
                        const accessor = json.accessors[accessorIndex];
                        const bufferView = json.bufferViews[accessor.bufferView];
                        
                        const byteOffset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
                        const componentType = accessor.componentType;
                        const count = accessor.count;
                        const type = accessor.type;

                        let itemSize;
                        if (type === 'SCALAR') itemSize = 1;
                        else if (type === 'VEC2') itemSize = 2;
                        else if (type === 'VEC3') itemSize = 3;
                        else if (type === 'VEC4') itemSize = 4;

                        let TypedArray;
                        if (componentType === 5126) TypedArray = Float32Array;
                        else if (componentType === 5123) TypedArray = Uint16Array;
                        else if (componentType === 5125) TypedArray = Uint32Array;

                        const binChunkOffset = 28 + json.buffers[0].byteLength;
                        const dataStart = binChunkOffset + byteOffset;
                        const arrayBuffer = glbData.slice(dataStart, dataStart + count * itemSize * TypedArray.BYTES_PER_ELEMENT);
                        const array = new TypedArray(arrayBuffer);

                        const attribName = attributeName === 'POSITION' ? 'position' : 
                                         attributeName === 'NORMAL' ? 'normal' : 
                                         attributeName === 'TEXCOORD_0' ? 'uv' : null;
                        
                        if (attribName) {
                            geometry.setAttribute(attribName, new THREE.BufferAttribute(array, itemSize));
                        }
                    });

                    if (primitive.indices !== undefined) {
                        const accessor = json.accessors[primitive.indices];
                        const bufferView = json.bufferViews[accessor.bufferView];
                        const byteOffset = (bufferView.byteOffset || 0) + (accessor.byteOffset || 0);
                        const count = accessor.count;
                        const componentType = accessor.componentType;

                        let TypedArray = componentType === 5123 ? Uint16Array : Uint32Array;
                        const binChunkOffset = 28 + json.buffers[0].byteLength;
                        const dataStart = binChunkOffset + byteOffset;
                        const arrayBuffer = glbData.slice(dataStart, dataStart + count * TypedArray.BYTES_PER_ELEMENT);
                        const indices = new TypedArray(arrayBuffer);

                        geometry.setIndex(new THREE.BufferAttribute(indices, 1));
                    }

                    const material = new THREE.MeshStandardMaterial({ color: 0xffffff });
                    const mesh = new THREE.Mesh(geometry, material);
                    group.add(mesh);
                });

                return group;
            };

            return GLTFLoader;
        })();

        init();
    </script>
</body>
</html>
